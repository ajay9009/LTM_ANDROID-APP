<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
  <div class="blog-post">

    <!--image of the header
    <div class="blog-post-img">
      <img src="c_icon.png" alt="icon" >
    </div>
    -->

    <div class="blog-post-info">
      <div class="blog-post-title">
        <h2>React Sass</h2>
      </div>
      <div class="blog-post-date">
        <!--<span>Friday</span>-->
        <!--<span>June 12 2020</span>-->
      </div>

      <!--post section-->
      <div class="blog-post-desc">
        
        <p><br>What is ES6?</br>
<br>ES6 stands for ECMAScript 6.

ECMAScript was created to standardize JavaScript, and ES6 is the 6th version of ECMAScript, it was published in 2015, and is also known as ECMAScript 2015.

</br>

<br>Why Should I Learn ES6?</br>

<br>React uses ES6, and you should be familiar with some of the new features like:

Classes
Arrow Functions
Variables (let, const, var)
</br>
<br>Classes</br>
<br>ES6 introduced classes.

A class is a type of function, but instead of using the keyword function to initiate it, we use the keyword class, and the properties are assigned inside a constructor() method.</br></p> 
        <h3>Example</h3>
        <p>A simple class constructor:</p>
        <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
		$myColor: red;
class Car {
  constructor(name) {
    this.brand = name;
  }
}

         </textarea><br>
         <h3>Example</h3>
         <p>Create an object called "mycar" based on the Car class:</p>
        <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
class Car {
  constructor(name) {
    this.brand = name;
  }
}

mycar = new Car("Ford");
</textarea><br>
<p><br>Method in Classes</br>
   You can add your own methods in a class:</p>
    <h3>Example</h3>
    <p>Create a method named "present":</p>
        <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
         class Car {
  constructor(name) {
    this.brand = name;
  }
  
  present() {
    return 'I have a ' + this.brand;
  }
}

mycar = new Car("Ford");
mycar.present();   

   </textarea><br>
   <p>As you can see in the example above, you call the method by referring to the object's method name followed by parentheses (parameters would go inside the parentheses).</p>
   <p><br>Class Inheritance</br>
    To create a class inheritance, use the extends keyword.

A class created with a class inheritance inherits all the methods from another class:
</br></p>
<h3>Example</h3>
    <p>Create a class named "Model" which will inherit the methods from the "Car" class:</p>

   <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
    class Car {
  constructor(name) {
    this.brand = name;
  }

  present() {
    return 'I have a ' + this.brand;
  }
}

class Model extends Car {
  constructor(name, mod) {
    super(name);
    this.model = mod;
  }  
  show() {
      return this.present() + ', it is a ' + this.model
  }
}
mycar = new Model("Ford", "Mustang");
mycar.show();
   
   </textarea><br>
<p>The super() method refers to the parent class.

By calling the super() method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods.</p>
<h2>Arrow Functions<h2>
<p><br>Arrow functions were introduced in ES6.
Arrow functions allow us to write shorter function syntax:</br></p>
 <h3>Before:</h3>  
 <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
    hello = function() {
  return "Hello World!";
}
</textarea><br>
 <h3>With Arrow Function:</h3>
 <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
   hello = () => {
  return "Hello World!";
}        
 </textarea><br>
        <p>It gets shorter! If the function has only one statement, and the statement returns a value, you can remove the brackets and the return keyword:</p>
 <h3>Arrow Functions Return Value by Default:</h3>
        <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
         hello = () => "Hello World!";  
        </textarea><br>
        <p>This works only if the function has only one statement.
If you have parameters, you pass them inside the parentheses:</p>
<h3>Arrow Function With Parameters:</h3>
 <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
     hello = (val) => "Hello " + val;      
        </textarea><br>
        <p>In fact, if you have only one parameter, you can skip the parentheses as well:</p>
        <h3>Arrow Function Without Parentheses:</h3>
 <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
hello = val => "Hello " + val;
</textarea><br>
<p><br>What About this?</br>
<br>The handling of this is also different in arrow functions compared to regular functions.
In short, with arrow functions there are no binding of this.
In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever.
With arrow functions, the this keyword always represents the object that defined the arrow function.
Let us take a look at two examples to understand the difference.
Both examples call a method twice, first when the page loads, and once again when the user clicks a button.
The first example uses a regular function, and the second example uses an arrow function.
The result shows that the first example returns two different objects (window and button), and the second example returns the Header object twice.</br></p>
 <h3>Example</h3>
 <p>With a regular function, this represents the object that called the function:</p>  
  <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">
   class Header {
  constructor() {
    this.color = "Red";
  }

//Regular function:
  changeColor = function() {
    document.getElementById("demo").innerHTML += this;
  }
}

myheader = new Header();

//The window object calls the function:
window.addEventListener("load", myheader.changeColor);

//A button object calls the function:
document.getElementById("btn").addEventListener("click", myheader.changeColor);
 </textarea><br>
<h3>Example</h3>
<p>With an arrow function, this represents the Header object no matter who called the function:</p>
 <textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">    
   class Header {
  constructor() {
    this.color = "Red";
  }

//Arrow function:
  changeColor = () => {
    document.getElementById("demo").innerHTML += this;
  }
}

myheader = new Header();


//The window object calls the function:
window.addEventListener("load", myheader.changeColor);

//A button object calls the function:
document.getElementById("btn").addEventListener("click", myheader.changeColor);        
   </textarea><br>     
<p>Remember these differences when you are working with functions. Sometimes the behavior of regular functions is what you want, if not, use arrow functions.</p>
<p><br>Variables</br>
<br>Before ES6 there were only one way of defining your variables: with the var keyword. If you did not define them, they would be assigned to the global object. Unless you were in strict mode, then you would get an error if your variables were undefined.

Now, with ES6, there are three ways of defining your variables: var, let, and const.</br></p>
<h3>var</h3>
<textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">    
  var x = 5.6;  
 </textarea><br>
<p><br>If you use var outside of a function, it belongs to the global scope.

If you use var inside of a function, it belongs to that function.

If you use var inside of a block, i.e. a for loop, the variable is still available outside of that block.

var has a function scope, not a block scope.</br></p>
<h3>let</h3>
<textarea id="code_container" name="code_container" rows="6" cols="50" readonly="">    
   let x = 5.6; 
</textarea><br>
<p>let has a block scope.

let is the block scoped version of var, and is limited to the block (or expression) where it is defined.

If you use let inside of a block, i.e. a for loop, the variable is only available inside of that loop.</p>
<h3>const</h3>
<textarea id="code_container" name="code_container" rows="6" cols="50" readonly=""> 
const x = 5.6;
</textarea><br>
<p>const is a variable that once it has been created, its value can never change.

const has a block scope.</p>

      </div>
      <!--/post section-->
    </div>
  </div>
</body>
</html>

<style type="text/css">
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@500&display=swap');
  body{
    font-family: 'Poppins', sans-serif;
    background-color: #008080;
}

textarea{
    display: flex;
    resize: none;
    width: 250px;
    height: auto;
    background-color: #25383C;
    border-radius: 2px;
    text-align: left;
    border-color: #999999;
    color: #FFFFFF;
    font-family: sans-serif;
}
.blog-post{
	
    display: flex;
    flex-direction:row;
    justify-content: center;
    align-items:center;
    background-color: #FEFCFF;
}
.blog-post-img{
    flex:1;
    padding:2rem 2rem 2rem 0rem;
}
.blog-post-img>img{
    width: 100%;
    height: 100%;
    border-radius: 0.3rem;
    object-fit: cover;
    transform: translateX(-50px);
    box-shadow:0px 0px 3px 3px rgba(0, 0 , 0, .5);
}
.blog-post-info{
    flex:2;
    padding: 2rem;
}
.blog-post-title h2{
    color:#673AB7;
    text-transform: uppercase;
}
.blog-post-read-more a{
    cursor: pointer;
    text-decoration: none;
    font-style: normal;
    border-radius: 0.3rem;
    padding:0.5rem;
    background-color: #fff;
    border:1px solid #673AB7;
    color: #673AB7 !important;
    box-shadow: 0 0.05em 0.1em rgba(0,0,0,.25);
}
.blog-post-read-more a:hover{
    transition: .5s;
    background-color: #673AB7;
    border: 1px solid #673AB7;
    color: #fff !important;
    text-decoration: none;
}
/*Extra small devices (phones , 600px and down)*/
@media only screen and (max-width: 600px){
    .blog-post{
    display: flex;
    flex-direction:column;
    margin-top: 3rem;
    margin-left:1rem;
    margin-right: 1rem;
    justify-content: center;
    align-items:center;
    background-color: white;
}
.blog-post-img{
    flex:1;
    padding:0rem 1rem 0rem 1rem;
}
.blog-post-img>img{
    width: 100%;
    height: 100%;
    border-radius: 0.3rem;
    object-fit: cover;
    transform: translateY(-20px);
    box-shadow:0px 0px 3px 3px rgba(0, 0 , 0, .5);
}
.blog-post-info{
    flex:2;
    padding:0rem 1rem 2rem 1rem;
}
}
/*Medium devices (tablets landscape)*/
@media only screen and (min-width: 768px){
.blog-post{
    display: flex;
    flex-direction:column;
    margin-top: 3rem;
    margin-left:1rem;
    margin-right: 1rem;
    justify-content: center;
    align-items:center;
    background-color: white;
}   
    .blog-post-img{
    flex:1;
    padding:0rem 1rem 0rem 1rem;
}
   .blog-post-img>img{
    width: 100%;
    height: 100%;
    border-radius: 0.3rem;
    object-fit: cover;
    transform: translateY(-20px);
    box-shadow:0px 0px 3px 3px rgba(0, 0 , 0, .5);
}
.blog-post-info{
    flex:2;
    padding:0rem 1rem 2rem 1rem;
}
}
/*Large devices (laptops)*/
@media only screen and (min-width: 992px){
    .blog-post{
    display: flex;
    flex-direction:row;
    margin: 10rem;
    justify-content: center;
    align-items:center;
    background-color: white;
    }
    .blog-post-img{
    flex:1;
    padding:2rem 2rem 2rem 0rem;
}
.blog-post-img>img{
    width: 100%;
    height: 100%;
    border-radius: 0.3rem;
    object-fit: cover;
    transform: translateX(-50px);
    box-shadow:0px 0px 3px 3px rgba(0, 0 , 0, .5);
}
.blog-post-info{
    flex:2;
    padding: 2rem;
}
}
</style>
 n